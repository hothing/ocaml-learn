# Изучаем OCaml решая школьные заадачки по программированию

## Задача 1 "Пятью пять - двадцать пять!"

Вася и Петя учатся в школе в одном классе. Недавно Петя поведал Васе о
хитром способе возведения в  квадрат натуральных чисел, оканчивающихся
на  цифру  5.  Теперь  Вася  может с  легкостью  возводить  в  квадрат
двузначные  (и даже  некоторые трехзначные)  числа, оканчивающиеся  на
5. Способ  заключается в  следующем: для  возведения в  квадрат числа,
оканчивающегося  на   5  достаточно  умножить  число,   полученное  из
исходного  вычеркиванием последней  пятерки  на  следующее по  порядку
число, затем  остается лишь приписать «25»  к получившемуся результату
справа.  Например,  для  того,  чтобы возвести  число  125  в  квадрат
достаточно 12 умножить  на 13 и приписать 25, т.е.  приписывая к числу
12*13=156      число      25,      получаем      результат      15625,
т.е. 1252=15625. Напишите  программу, возводящую число, оканчивающееся
на 5, в квадрат для того, чтобы Вася смог проверить свои навыки.

### Решение
```ocaml
let check_last_digit x n =
    if n <= 9 then (x - n) mod 10 = 0 else false;;
let reduce_one_digit x = x / 10;;
let magic_square x =
    let y = reduce_one_digit x in
       if check_last_digit x 5 then (y * (y + 1))*100 + 25 else 0;;
```

## Задача 2

В свободное время  одноклассники Вася и Петя любят  играть в различные
логические игры: морской бой, крестики-нолики, шахматы, шашки и многое
другое. Ребята уже испробовали и поиграли во всевозможные классические
игры  подобного  рода,  включая компьютерные.  

Однажды  им   захотелось  сыграть  во  что-нибудь   новое,  но  ничего
подходящего  найти не  удалось.   Тогда Петя  придумал следующую  игру
«Угадайка»:   Играют  двое   участников.    Первый  загадывает   любое
трехзначное число, такое что первая  и последняя цифры отличаются друг
от  друга  более  чем  на   единицу.   Далее  загадавший  число  игрок
переворачивает  загаданное  число,  меняя  первую  и  последнюю  цифры
местами, таким образом получая еще одно число.  Затем из максимального
из  полученных  двух  чисел вычитается  минимальное.   Задача  второго
игрока –  угадать по первой  цифре полученного в  результате вычитания
числа  само это  число.  Например,  если  Вася загадал  число 487,  то
перестановкой первой  и последней  цифры он  получит число  784. После
чего  ему  придется  вычесть  из  784 число  487,  в  результате  чего
получится  число 297,  которое  и должен  отгадать  Петя по  указанной
первой цифре «2», взятой из этого числа.

Петя  успевает лучше  Васи по  математике, поэтому  практически всегда
выигрывает в  играх такого  типа. Но  в данном  случае Петя  схитрил и
специально придумал такую игру, в которой он не проиграет Васе в любом
случае.   Дело в  том,  что придуманная  Петей  игра имеет  выигрышную
стратегию,  которая  заключается  в следующем:  искомое  число  всегда
является трехзначным  и вторая  его цифра всегда  равна девяти,  а для
получения  значения  последней  достаточно отнять  от  девяти  первую,
т.е. в рассмотренном выше случае последняя цифра равна 9-2=7. Помогите
Пете еще  упростить процесс отгадывания  числа по заданной  его первой
цифре, написав соответствующую программу.

### Решение
```ocaml
let rec pow10 n = if n >= 1 then 10 * pow10 (n - 1) else 1;;
  
let lead_digits_at x n = if n >= 0 then x / (pow10 n) else 0;;
let tail_digits_at x n = if n > 0 then x mod (pow10 n) else 0;; 

let digit_at x n = tail_digits_at (lead_digits_at x n) 1;;

assert((digit_at 1234 0) = 4);;
assert((digit_at 1234 1) = 3);;
assert((digit_at 1234 2) = 2);;
assert((digit_at 1234 3) = 1);;
assert((digit_at 1234 4) = 0);;

let check_3digits x =
  let 
      fd = digit_at x 2
    and
      ld = digit_at x 0
  in ((fd - ld) > 1) || ((ld - fd) > 1);;

let reverse_3digits x =
  let y = tail_digits_at x 3
    and
      fd = digit_at x 2
    and
      md = digit_at x 1
    and
      ld = digit_at x 0
  in ld * (pow10 2) + md * (pow10 1) + fd * (pow10 0);;
  
    
  assert((reverse_3digits 123) = 321);;
  assert((check_3digits 123));;
    
    
    (* Direct task *)

  let emax x y = if x > y then x else y;;
  let emin x y = if x < y then x else y;;
    
  let encode x =
    let y = tail_digits_at x 2
    in if check_3digits y then
         let mx = emax (reverse_3digits y) y
           and
             nx = emin (reverse_3digits y) y
         in mx - nx
       else 0;;

    (* Inverse task *)

  let decode x =
    let 
      fd = digit_at x 0
    in if x <= 9 then
         fd * (pow10 2) + 9 * (pow10 1) + (9 - fd) * (pow10 0)
    else 0;;
```

## Задача 3 "Статистика"

Вася не любит  английский язык, но каждый раз  старается получить хотя
бы  четверку  за  четверть,  чтобы  оставаться  ударником.  В  текущей
четверти  Вася  заметил  следующую закономерность:  по  нечетным  дням
месяца он получал тройки, а по четным  – четверки. Так же он помнит, в
какие дни он получал эти оценки. Поэтому он выписал на бумажке все эти
дни  для  того,  чтобы  оценить,   сколько  у  него  троек  и  сколько
четверок.  Помогите Васе  это  сделать, расположив  четные и  нечетные
числа в  разных строчках.  Вася может рассчитывать  на оценку  4, если
четверок не меньше, чем троек.

Нужно  вывести числа,  которые соответствуют  дням месяцев,  в которые
Вася  получил тройки,  а во  второй строке  соответственно расположить
числа месяца, в которые Вася  получил четверки. В третьей строке нужно
вывести  «YES», если  Вася может  рассчитывать  на четверку  и «NO»  в
противном случае.

### Решение
```ocaml
let even x = x mod 2 = 0;;
let odd x = if even x then false else true;;
  
let rec filter list pred =
  match list with
  | [] ->[]
  | hd::tl ->
     let new_tl = filter tl pred in
     if pred hd then hd::new_tl else new_tl;;

  
let mark_dates = [29; 4; 7; 12; 15; 17; 24; 1];;

let good_dates = filter mark_dates even;;

let bad_dates = filter mark_dates odd;;

if (List.length good_dates) > (List.length bad_dates) then "YES" else "NO";;  

```

## Задача 4 "НОК"

Требуется  написать программу,  определяющую наименьшее  общее кратное
(НОК) чисел a и b. Заданы два  натуральных числа А и В, не превышающих
46340.

### Подготовка
НОК = lcm
НОД = gcd

lcm(a ,b) = |a * b| / gcd(a, b)

Для вычисления НОД можно использовать алгоритм Евклида:
Пусть a и b — целые числа, не равные одновременно нулю, и последовательность чисел

    a > b > r1 > r2 > r3 > r4 > … > rn 

определена тем, что каждое rk — это остаток от деления предпредыдущего
числа на предыдущее,  а предпоследнее делится на  последнее нацело, то
есть:

    a = b * q0 + r1 ,
    b = r1 * q1 + r2 , 
    r1 = r2 * q2 + r3 , 
    ⋯ 
    r{k − 2} = r{k − 1} * q{k − 1} + r{k}, 
    ⋯
    r{n − 2} = r{n − 1} * q{n − 1} + r{n},
    r{n − 1} = r{n} * q{n}.

Тогда НОД(a, b), наибольший общий делитель a и b, равен rn, последнему
ненулевому члену этой последовательности.

И как всегда простому человеку непонятно что же с этим делать :(

Думаю это должно быть так:

    q0 = a / b
	r1 = a - q0 * b
	q1 = b / r1
	r2 = b - q1 * r1
	q2 = r1 / r2
	r3 = r1 - q2 * r2
	q3 = r2 / r3
	r4 = r2 - q3 * r3
	
	while r{k} /= 0

Можно использовать бинарный алгоритм:
    
	НОД(0, n) = n; НОД(m, 0) = m; НОД(m, m) = m;
    НОД(1, n) = 1; НОД(m, 1) = 1;
    Если m, n чётные, то НОД(m, n) = 2*НОД(m/2, n/2);
    Если m чётное, n нечётное, то НОД(m, n) = НОД(m/2, n);
    Если n чётное, m нечётное, то НОД(m, n) = НОД(m, n/2);
    Если m, n нечётные и n > m, то НОД(m, n) = НОД((n-m)/2, m);
    Если m, n нечётные и n < m, то НОД(m, n) = НОД((m-n)/2, n);

### Решение НОД1
```ocaml
let rec gcd1 a b = if a > b then let
                       q = a / b
                     in let r = a - q * b
                        in if r > 0 then gcd1 b r else b
                     else gcd1 b a;;
```

### Решение НОД2
```ocaml
let even x = x mod 2 = 0;;
let odd x = if even x then false else true;;

let rec gcd2 a b = if a = 0 then b else
                 if b = 0 then a else
                   if a = 1 then a else
                     if b = 1 then b else
                       if a = b then a else
                         if (even a) && (even b) then 2 * gcd2 (a / 2) (b / 2) else
                           if (even a) && (odd b) then gcd2 (a / 2) b else
                             if (odd a) && (even b) then gcd2 a (b / 2) else
                               if a < b then gcd2 ((b - a) / 2) a else gcd2 ((a - b) / 2) b;;
```

### Решение НОК
```ocaml
let lcm0 a b fgcd = let
    x = a * b
  and
    mmax = 46340
  in if (a <= mmax) && (b <= mmax) then if x > 0 then x / fgcd a b else -x / fgcd a b else 0;;
                   
let lcm1 a b = lcm0 a b gcd1;;

let lcm2 a b = lcm0 a b gcd2;;
```

## Задача 5 "Дороги"

В  галактике  «Milky  Way»  на планете  «Snowflake»  есть  N  городов,
некоторые из  которых соединены  дорогами. Император  галактики «Milky
Way» решил  провести инвентаризацию дорог на  планете «Snowflake». Но,
как  оказалось,  он не  силен  в  математике,  поэтому он  просит  вас
сосчитать количество  дорог. Требуется написать  программу, помогающую
императору сосчитать количество дорог на планете «Snowflake».

Задано число N (0 ≤ N ≤ 100).  В N строках записано по N чисел, каждое
из которых является единичкой или  ноликом. Причем, если в позиции (i,
j) квадратной матрицы стоит единичка,  то i-ый и j-ый города соединены
дорогами, а если нолик, то не соединены.

### Решение 
```ocaml
```
